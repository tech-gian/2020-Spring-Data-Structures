![run-tests](../../workflows/run-tests/badge.svg)

## 2020 Project 3

Εκφώνηση: https://k08.chatzi.org/projects/project3/


### Προσωπικά στοιχεία

__Όνομα__: Ιωάννης Ζαπάντης

__Α.Μ.__: sdi1900059

### Ασκήσεις που παραδίδονται

- Άσκηση 1
    Παραδίδεται στο folder modules/UsingHashTable/ADTMap.c

- Άσκηση 2
    Παραδίδεται στο folder modules/UsingAdjacencyLists/ADTGraph.c
    (Έχουν γραφθεί και αντίστοιχα tests στο folder tests/ADTGraph_test.c)

- Άσκηση 3
    Παραδίδεται στο folder modules/DiseaseMonitor.c

- Bonus_tests_Άσκηση_3
    Παραδίδεται στο folder tests


### Documentation

# Άσκηση 1
    Στην άσκηση αυτή υλοποιήθηκε το ADTMap, με την χρήση Hash Table.
    Για την υλοποίηση χρησιμοποιήθηκε η μέθοδος του separate chaining.

    Σύμφωνα με αυτήν την μέθοδο, το Map είναι ένας πίνακας στον οποίο
    για index αντιστοιχούν keys (αφού έχουν γίνει hash, με την εκάστοτε
    hash_function). Κάθε κόμβος του Map περιέχει μία λίστα, στην οποία
    είναι αποθηκευμένα τα MapNodes, των οποίων τα keys hashaρουν στο
    αντίστοιχο index του πίνακα.

    Όλες οι λειτουργίες του Map έχουν υλοποιηθεί σύμφωνα με το ADTMap.h
    αρχείο, το οποίο δίνει σαφείς οδηγίες για το τι κάνει κάθε συνάρτηση.
    
    Πέρα από τις διαφορές στην υλοποίηση, λόγω της διαφορετικής μεθόδου
    που χρησιμοποιείται (σε σχέση δηλαδή με open addresing), η βασική διαφορά
    είναι ότι ο load_factor πρέπει (σύμφωνα με την θεωρία) να παραμένει < 0.9,
    ώστε όλες οι λειτουργίες να είναι αποδοτικές (με πολυπλοκότητες που
    αναφέρονται στην θεωρία).
    
    (Περισσότερες λεπτομέρειες, σχετικά με τον τρόπο που υλοποιήθηκε η κάθε
    λειτουργία, αναφέρονται στα σχόλια στο .c αρχείο)


# Άσκηση 2
    Στην Άσκηση αυτή υλοποιήθηκε το ADTGraph, με την χρήση του ADTMap που
    υλοποιήθηκε στην προηγούμενη άσκηση. Ακόμα, δημιουργήθηκαν tests για
    τον έλεγχο όλων των λειτουργιών του γράφου.

    Ο γράφος ουσιαστικά είναι ένα map, στο οποίο έγινε η αντιστοίχηση
    key->vertex (κορυφή), value->λίστα-γειτνίασης. Η λίστα-γειτνίασης
    υλοποιήθηκε με το ADTList, που υπήρχε ήδη. Δηλαδή, σε κάθε κορυφή αντιστοιχείζεται
    μια λίστα με όλους του γείτονες, η οποία δημιουργεί και την έννοια των ακμών.
    Όλες οι λειτουργίες που γίνονται στον γράφου περιγράφονται στο header file και
    υλοποιούνται με τον προφανή τρόπο. Περισσότερες λεπτομέρειες αναφέρονται
    στα σχόλια του κώδικα.

    Ειδική περίπτωση αποτελεί η graph_shortest_path, η οποία υλοποιήθηκε με τον
    αλγόριθμο του Dijkstra. Για μεγαλύτερη ευκολία χρησιμοποιήθηκε ένα έξτρα map
    και μια PriorityQueue (ο κώδικας αντιγράφθηκε από το lecture-code). Στο map
    εισάχθηκαν οι κορυφές ως keys και τα αντίστοιχα PQNodes ως values. Στην
    pqueue εισάχθηκαν structs, τα οποία έγιναν typedefed σε Vertex, και περιέχουν
    όσες πληροφορίες χρειάζεται για την σωστή υλοποίηση του αλγορίθμου.

    (Οι επιπλέον δομές γίνονται destroy κατά την κλήση της shortest_path)
    (Η λίστα που επιστρέφεται είναι ευθύνη του χρήστη να γίνει destroy, όπως αναφέρει
    και το .h αρχείο)

    Υποσημείωση: Επειδή στο ADTMap χρησιμοποιείται η υλοποίηση με hash table, πρέπει
    κατά την δημιουργία του γράφου να κληθεί και η graph_set_hash_function.


# Άσκηση 3
    Στην υλοποιήθηκε το DiseaseMonitor, όπως ζητείται από την εκφώνηση. Για την
    υλοποίηση χρησιμοποιήθηκε ένας συνδιασμός από Map, Set, PriorityQueue και
    List (κυρίως για την επιστροφή λιστών που ζητούσαν κάποιες συναρτήσεις).
    Σκοπός του module αυτού είναι η αποθήκευση διαφόρων records σχετικά με
    κρούσματα από ασθένειες και η εξαγωγή κάποιων στατιστικών από αυτά.

    Στην υλοποίηση χρησιμοποιήθηκε ένα global struct, το οποίο αποτελούταν από
    όλες τις βασικές δομές που χρησιμοποιήθηκαν. Περιέχει ένα βασικό Map, το
    οποίο διατηρεί όλα τα records (για γρήγορο insert και remove, έλεγχος αν υπάρχει ήδη).
    Ακόμα, χρησιμοποιείται ένα Map, με διάταξη κατά disease, στο οποίο σε κάθε node
    αποθηκεύεται άλλο Map, με διάταξη κατά country, στο οποίο σε κάθε node αποθηκεύεται
    ένα Set, με διάταξη κατά date, στο οποίο αποθηκεύονται όλα τα records που αντιστοιχούν
    σε αυτό το disease, country και date. Έτσι ομαδοποιούνται ανά κατηγορίες τα records.
    Αυτό βοηθάει στο να επιστρέφει πιο γρήγορα η dm_get_records τα αποτελέσματά της.

    Η dm_count_recors απλά ελέγχει τι δεδομένα δόθηκαν και μετράει αντίστοιχα τα
    sizes των αντίστοιχων δομών. Έτσι επιστρέφει τον αριθμό των records που πληρούν τα
    κριτήρια, χωρίς να χρειαστεί να προσπελάσει (και να μετρήσει) όλα τα records, πχ
    με την κλήση της dm_get_records.

    Οι λειτουργίες insert και remove, απλά κάνουν εισαγωγή και διαγραφή προς/από τις δομές που
    πρέπει να γίνουν, ανάλογα το record που δίνεται.

    Η dm_top_diseases χρησιμοποιεί μία δική της δομή. Αν το country που δοθεί είναι ίσο με NULL,
    τότε χρησιμοποιεί την country_null, δηλαδή ένα struct με Map και Pqueue, στην οποία pqueue
    είναι ταξινομημένες όλα τα diseases, ώστε στο pqueue_max να υπάρχει το disease με τα
    περισσότερα κρούσματα. To Map χρησιμοποιείται για το insert και το remove.
    Αντίστοιχα, όταν δοθεί country != NULL χρησιμοποιείται η ίδια διαδικασία, απλά τώρα σε ένα
    Map (key->country, value->MapPq) βρίσκουμε την country που δόθηκε και επιστρέφουμε το
    pqueue_max της country αυτής.

    Τα Set και List που χρησιμοποιούνται, δημιουργούνται από τις υλοποιήσεις του lecture-code
    (και του ADTList που υπήρχε ήδη στο project-3). Το PriorityQueue που χρησιμοποιείται, είναι
    η δική μου υλοποίηση (αντεγραμμένη από το project-2), διότι χρειαζόταν η pqueue_update_order.
    Τα Map που χρησιμοποιούνται, είναι με την υλοποίηση που έγινε για την Άσκηση 1, δηλαδή
    UsingHashTable με separate chaining.

    Η υλοποίηση του DiseaseMonitor.c περνάει όλα τα tests (που υπήρχαν ήδη στο project-3) και
    χωρίς leaks.

    Υποσημείωση: το .c file βρίσκεται στο folder modules, χωρίς να βρίσκεται μέσα σε άλλο folder,
    αφού δεν χρησιμοποιεί μοναδική δομή (πχ UsingHashTable, που υπήρχε για το ADTMap).


# Bonus_tests_Άσκηση_3:
    Υλοποιήθηκαν κάποιοι παραπάνω έλεγχοι για το DiseaseMonitor. Κυρίως κάποιες ακραίες καταστάσεις,
    οι οποίες όμως είναι πιθανό να δημιουργηθούν. Θεώρησα σκόπιμο, να αντιγράψω τον κώδικα από
    το test που μας δόθηκε αρχικά, αφού χρησιμοποιώ το ίδιο αρχείο records και το θεώρησα
    ορθότερο να είναι ολοκληρωμένο το test με όλους τους ελέγχους συγκεντρωμένους.
    
    Για να τρέξουν τα tests, έχει προστεθεί στο Makefile, ό,τι χρειάζεται ώστε να τρέχει με τον
    γνωστό τρόπο make run-DiseaseMonitor_bonus_test και αντίστοιχα για το valgrind.
    
    Η υλοποίηση του DiseaseMonitor, περνάει και αυτά τα tests και χωρίς leaks.
