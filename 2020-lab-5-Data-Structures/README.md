![run-tests](../../workflows/run-tests/badge.svg)

## Δομές Δεδομένων και Τεχνικές Προγραμματισμού

### Κώδικας Εργαστηρίου 5

Εκφώνηση: https://k08.chatzi.org/labs/lab5/ 


# Άσκηση 2 (Γενική Συνάρτηση set_visit):
    Σε αυτήν την άσκηση υλοποιήθηκε η set_visit,
    με τον απλό(προφανή) τρόπο. Δηλαδή, ξεκινάει
    ένα for..loop από το πρώτο σε διάταξη στοιχείο
    του Set (set_first) και συνεχίζει (set_next) μέχρι
    το τελευταίο σε διάταξη στοιχείο. Για κάθε στοιχείο
    που υπάρχει στο Set, καλεί την visit (VisitFunc),
    η οποία δίνεται σαν όρισμα στην set_visit.

    Η πολυπλοκότητα εξαρτάται άμεσα από την πολυπλοκότητα
    της set_first και της set_next, όπου η κάθε μία είναι
    O(h), όπου h είναι το ύψος του δέντρου. Αυτές, συνολικά,
    καλούνται n φορές, όπου n είναι το πλήθος των στοιχείων
    του δέντρου.
    Άρα:
        -Για το BinarySearchTree, η πολυπλοκότητα της set_visit
        είναι O(n*h).
        -Για το AVL, η πολυπλοκότητα της set_visit είναι
        O(n*logn), αφού από τα rotations που γίνονται, το ύψος
        του δέντρου παραμένει πάντα logn.
        -Για το BTree, η πολυπλοκότητα της set_visit είναι
        O(n*logn), αφού με το ύψος του δέντρου διατηρείται logn.

# Άσκηση 3 (Αποδοτική υλοποίηση της set_visit):
    Σε αυτήν την άσκηση υλοποιήθηκε η set_visit,
    με τον αποδοτικό(αναδρομικό) τρόπο. Ξεκινώντας από την ρίζα
    προχωράμε μέχρι το μικρότερο στοιχείο του δέντρου και
    συνεχίζουμε αναδρομικά προς το μεγαλύτερο (πάντα σε σχέση
    με την διάταξη της compare). Ο αλγόριθμος έχει την ίδια λογική
    και στις 2 υλοποιήσεις, απλά έγιναν οι κατάλληλες τροποποιήσεις
    ώστε στο BTree να γίνεται η ίδια διαδικασία (λόγω των περισσοτέρων
    παιδιών).

    Η πολυπλοκότητα σε κάθε υλοποίηση είναι O(n), αφού παρόλο
    της αναδρομής, προσπελαύνονται όλα τα στοιχεία του δέντρου
    ακριβώς μία φορά. Απλά, με αυτόν τον αποδοτικό τρόπο γλυτώνουμε
    το να ξεκινάει κάθε φορά η set_visit από την ρίζα και να διασχίζει
    όλο το ύψος του δέντρου. Τώρα απλά μετακινείται σε κάποιον (ανάλογα
    κάθε φορά) κοντινό κόμβο.

### Προαιρετικά:
    Μετρήθηκε ο χρόνος με την συνάρτηση clock(), για 50000 στοιχεία.
    (Στα test έχει παραμείνει το Ν = 1000, ενώ ακόμα έχει προστεθεί
    ένα ακόμα test για την set_visit_efficient).

        - Στην υλοποίηση με BinarySearchTree ο απλός τρόπος
        έκανε περίπου 12 sec ενώ ο αποδοτικός περίπου 0,00059 sec.
        - Στην υλοποίηση με AVL ο απλός τρόπος έκανε περίπου 0,00158 sec
        ενώ ο αποδοτικός περίπου 0,00083 sec.
        - Στην υλοποίηση με BTree ο απλός τρόπος έκανε περίπου 0,0076 sec
        ενώ ο αποδοτικός περίπου 0,00097 sec.

    Σε όλες τις περιπτώσεις φαίνεται η διαφορά στον χρόνο εκτέλεσης, το
    οποίο οφείλεται στην καλύτερη πολυπλοκότητα.
