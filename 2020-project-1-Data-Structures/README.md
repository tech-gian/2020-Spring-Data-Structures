![run-tests](../../workflows/run-tests/badge.svg)

## 2020 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/


### Προσωπικά στοιχεία

__Όνομα__: Ιωάννης Ζαπάντης

__Α.Μ.__: sdi1900059


### Documentation


## Γενικές Οδηγίες:
    Για κάθε άσκηση έχει γραφθεί κι ένα ξεχωριστό Makefile,
    το οποίο έχει τις λειτουργίες που αναφέρονται στην κάθε
    άσκηση παρακάτω.



# Άσκηση 1:
    Η άσκηση λύθηκε με μια απλή υλοποίηση, χρησιμοποιώντας array.
    Το αρχείο με τις περισσότερες λέξεις, words-100000 έτρεξε σε
    χρόνο 28 sec (με τις εκτελέσεις printf).
    
    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Το Makefile περιέχει τις απλές λειτουργίες make, run, clean
    και valgrind.


# Άσκηση 2:
    Η άσκηση λύθηκε με την χρήση ADTMap. Κάθε word όταν βρίσκεται
    πρώτη φορά εισάγεται στο Map, ως key το ίδιο το word και ως value
    το 1 (τις φορές που έχει βρεθεί) και εκτυπώνεται 0. Αλλιώς 
    εκτυπώνεται ο αριθμός του value και μετά αυξάνεται κατά 1.
    Το words-100000 έτρεξε σε χρόνο 12 sec (με τις εκτελέσεις printf).
    
    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Το Makefile περιέχει τις απλές λειτουργίες make, run, clean
    και valgrind.


# Άσκηση 3:
    Η άσκηση λύθηκε με την χρήση ADTSet. Διαβάζω μία προς μία
    τις γραμμές και εκτυπώνω την μικρότερη από τις προηγούμενες και
    μεγαλύτερη από αυτήν που μόλις διαβάστηκε.

    Στο folder programs/Exercise_3 υπάρχει και το ex3_test.txt
    το οποίο περιέχει τις προτάσεις που δίνονται στην εκφώνηση,
    για δοκιμαστική χρήση.

    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Το Makefile περιέχει τις απλές λειτουργίες make, run, clean
    και valgrind.


# Άσκηση 4:
    Στην άσκηση αυτή υλοποίησα τις 2 συναρτήσεις pq_sort_vector και
    pq_sort_list, που σκοπός τους είναι να ταξινομούν ένα vector και
    μία λίστα χρησιμοποιώντας priority queue. Λεπτομέρειες για την
    υλοποίηση βρίσκονται στα σχόλια.
    Έχει προστεθεί test για την pq_sort_list, αφού για το vector
    υπήρχαν ήδη. Βρίσκονται στο tests/pq_sort_test, με αντίστοιχο
    .c αρχείο (με τα tests) και το Makefile.
    
    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Το Makefile περιέχει τις απλές λειτουργίες make, run, clean
    και valgrind.


# Άσκηση 5:
    Στην άσκηση αυτή ζητείται να υλοποιήσουμε τις συναρτήσεις, των
    οποίων τα ορίσματα δίνονται στην εκφώνηση. Οι συναρτήσεις αυτές
    έχουν ως σκοπό την υλοποίηση του "Παιχνιδιού της Ζωής".

    Ένα LifeState είναι απλά ένα Map, που έχει γίνει typedef σε
    LifeState. Το Map αυτό έχει για key ένα LifeCell, που έχει
    τις συντεταγμένες του συγκεκριμένου κελιού και σαν value
    true ή false, αντίστοιχα αν είναι ζωντανό ή όχι το κελί αυτό.


    - Με την life_create() δημιουργούμε ένα LifeState, το οποίο
    είναι απλά ένα Map, το οποίο έχει γίνει typedef σε LifeState.
    Η συνάρτηση επιστρέφει το LifeState.

    - Με την life_create_from_rle(char* file) δημιουργούμε ένα LifeState,
    από το file (.rle), το οποίο (με βάση του κανόνες του παιχνιδιού)
    περιγράφει μια κατάσταση του παιχνιδιού.
    Η συνάρτηση επιστρέφει το LifeState.

    - Με την life_save_to_rle(LifeState state, char* file) αντίστοιχα
    αποθηκεύουμε το state, στο file (.rle). Είναι ακριβώς η αντίστροφη
    διαδικασία της life_create_from_rle().

    - Με την life_get_cell(LifeState state, LifeCell cell) επιστρέφουμε
    την τιμή bool του cell, που βρίσκεται στο state. Αν το κελί είναι
    ζωντανό (δηλαδή υπάρχει στο Map), επιστρέφει true, αλλιώς επιστρέφει
    false (αφού το κελί θα είναι αναγκαστικά νεκρό).

    - Με την life_set_cell(LifeState state, LifeCell cell, bool value)
    ορίζουμε την value (true ή false) στο cell, που βρίσκεται στο state.
    Ουσιαστικά, αποθηκεύουμε την value μόνο αν είναι true, αλλιώς δεν
    την αποθηκεύουμε (λόγω της λειτουργίας της life_get_cell()).

    - Με την life_evolve(LifeState state) κάνουμε evolve στο state
    και επιστρέφουμε την επόμενη κατάσταση του state, η οποία προκύπτει
    από τους κανόνες εξέλιξης που δίνονται στην εκφώνηση.

    - Με την life_destroy(LifeState state) κάνουμε destroy στο state,
    απλά καλώντας την map_destroy(), αφού το state είναι απλά ένα Map.


    Για όλες αυτές τις συναρτήσεις έχουν υλοποιηθεί αντίστοιχα tests,
    τα οποία βρίσκονται στο tests/life_test. Εκτός του .c αρχείου, που
    περιέχει τα tests, υπάρχει ένα Makefile με τις απλές λειτουργίες
    make, run, clean και valgrind. Ακόμα, υπάρχουν και κάποια αρχεία
    .rle, τα οποία χρειάζονται για να τρέξουν κάποια tests.
    Τα memory leaks έχουν ελεγχθεί με valgrind.


# Άσκηση 6:
    Στην άσκηση αυτή υλοποιήθηκε η συνάρτηση
    life_evolve_many(LifeState state, int steps, ListNode* loop).
    Κάνουμε steps εξελίξεις με την life_evolve() και βάζουμε τα states
    που προκυπτον σε μια λίστα, την οποία και επιστρέφουμε. Αν βρεθεί
    επανάληψη στον τρόπο που παράγονται οι καταστάσεις, επιστρέφουμε
    στο loop, τον κόμβο που πρέπει να συνεχίσει η επανάληψη, αλλιώς NULL.
    Η αναζήτηση ίδιας κατάστασης έγινε με την χρήση Map, με κατάλληλη
    compare function για LifeStates.
    Η life_evolve_many() μπορεί να αποδεσμεύσει μόνο την μνήμη για το
    Map και τα values που περιέχονται σε αυτόν. Οι καταστάσεις που
    παράγονται (και αποθηκεύονται στην λίστα) είναι υπόθεση της συνάρτησης
    που την καλεί να τις διαγράψει.
    Επίσης δεν μπορεί να περαστεί κάποια DestroyFunc, οπότε περνάμε NULL
    και αποδεσμεύονται manually τα values της λίστας από τις συναρτήσεις
    που χρησιμοποιούν την λίστα.

    Ακόμα, μαζί με τα tests για τις πρώτες 6 συναρτήσεις (Άσκηση 5),
    έχουν προστεθεί και 2 tests (με και χωρίς loop) για την
    life_evolve_many (άμα δεν χρειάζονται, έχουν γραφθεί για έλεγχο
    της συνάρτησης).
    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Για τα tests αυτά υπάρχει Makefile (το ίδιο με αυτό της Άσκησης 5)
    που έχει τις ίδιες λειτουργίες που αναλύθηκαν παραπάνω.



    -Επίσης, έχει δημιουργηθεί το αρχείο life_gif.c, με το οποίο
    δημιουργούμε το gif αρχείο με την βοήθεια των προηγούμενων
    συναρτήσεων.

    Τα arguments που παίρνει αυτό το πρόγραμμα είναι αυτά που δίνονται
    στην εκφώνηση της άσκησης (εκτός του zoom) και πρέπει να δοθούν με
    αυτήν την σειρά. Δεν θεώρησα απαραίτητο για αυτήν την εργασία να
    ελέγχω ότι στην είσοδο δίνονται σωστά δεδομένα, απλά θεώρησα ότι
    αυτό θα γίνεται.

    Το pattern που θα δοθεί, θα ξεκινήσει από την μέση (περίπου) του
    πλαισίου που ορίζουν τα όρια top, down, left, right. Κάθε pattern
    αρχίζει από το κελί (0, 0). Οπότε συνίσταται τα top και left να είναι
    0 και 0, και τα left, down να ποικίλλουν ανάλογα το μέγεθος που gif
    που θέλουμε να εμφανίσουμε. 

    Τα memory leaks έχουν ελεγχθεί με valgrind.
    Στο folder tests/life_test υπάρχει και το αντίστοιχο Makefile, το
    οποίο έχει τις απλές λειτουργίες make, run, clean και valgrind.
    Τα ορίσματα του προγράμματος δίνονται στο ARGS. Ακόμα, πρέπει στο folder
    αυτό να υπάρχει και ένα αρχείο .rle που περιέχει το αρχικό pattern
    και το όνομα του αρχείου αυτού να δοθεί στο όρισμα <state>.
    To αρχείο .gif θα δημιουργηθεί στο ίδιο folder.
